---
layout: post
title: "Android Security: Beware of the default IV!"
---

A quick one today. A couple of people I have spoken to recently have been unaware of the need to ensure a random IV is being used when performing AES encryption on Android.

The unawareness seems to fall into two camps:

1. I didn't know I needed to use an IV
2. I am using the IV that is generated by the Cipher

## I didn't know I needed to use an IV

[Yup!](https://security.stackexchange.com/questions/35210/encrypting-using-aes-256-do-i-need-iv/35216#35216)

## I am using the IV that is generated by the Cipher

[Uh oh!](https://stackoverflow.com/questions/31036780/android-cryptography-api-not-generating-safe-iv-for-aes)

## Enforcing a random IV

Its worth explicitly declaring an IV to avoid the vulns introduced with either of the above two approaches. This can be as simple as:

```
public byte[] encrypt(byte[] in)
{
    ...
    byte[] iv = new byte[IV_LENGTH];
    new SecureRandom().nextBytes(iv);
    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
    byte[] encrypted = cipher.doFinal(s.getBytes("UTF-8"));
    return concat(encrypted, iv);
}

public byte[] decrypt(byte[] in) throws SecurityException
{
    ...
    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(bytes, bytes.length-IV_LENGTH, IV_LENGTH));
    return new cipher.doFinal(bytes, 0, bytes.length-IV_LENGTH);
}
```

[Some](https://developer.android.com/reference/javax/crypto/Cipher.html) of the Android examples do now suggest this, but I find it can be easy to forget when looking at [other](https://developer.android.com/reference/android/security/keystore/KeyGenParameterSpec.html) example code.

_If interested in Android security I have been collecting some notes on the subject at [doridori/Android-Security-Reference](https://github.com/doridori/Android-Security-Reference)_




